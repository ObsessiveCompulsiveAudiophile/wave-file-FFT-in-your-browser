async function getXovers() {
  const getColorForValue = (value, minValue, maxValue, applyGradient = true) => {
    if (!applyGradient) return '';
    if (isNaN(value) || isNaN(minValue) || isNaN(maxValue) || minValue === maxValue) return '';
    const normalizedValue = (value - minValue) / (maxValue - minValue);
    const hue = 120 * normalizedValue;
    const saturation = 0.7;
    const lightness = 0.3;
    return `hsl(${hue}, ${saturation * 100}%, ${lightness * 100}%)`;};
  isLarge = new Array(nSpeakers + 1).fill(false);
  allPass = new Array(nSpeakers + 1).fill(false);
  let frequencyMaxSums = {}, singleCount = 0;
  const peakTime = await findTruePeak(1);
  for (let i = 1; i <= nSpeakers;) {
    await postNext('Offset t=0', i, {offset: peakTime, unit: "seconds"});
    let isPair = !["C", "CH", "SB", "TS"].includes(commandId[i]);
    if (commandId[i] === "SBL" && !commandId.includes("SBR")) isPair = false;
    console.infoBold(`Analysing crossover frequencies for speaker${isPair ? ` pair ${commandId[i]} + ${commandId[i + 1]}` : ` ${commandId[i]}`}`);
    const interXo1 = await xoInter(i);
    console.info(`${commandId[i]} drops below target curve @ ${interXo1.toFixed(2)}Hz`);
    const {scores: scores1, scoresAP: scoresAP1, adjustedScores: adjustedScores1, adjustedScoresAP: adjustedScoresAP1, xoIndex} = await xoScores(i, interXo1);
    await postNext('Offset t=0', i, {offset: -peakTime, unit: "seconds"});
    if (isPair) {
      const interXo2 = await xoInter(i + 1);
      console.info(`${commandId[i + 1]} drops below target curve @ ${interXo2.toFixed(2)}Hz`);
      await postNext('Offset t=0', i + 1, {offset: peakTime, unit: "seconds"});
      const {scores: scores2, scoresAP: scoresAP2, adjustedScores: adjustedScores2, adjustedScoresAP: adjustedScoresAP2} = await xoScores(i + 1, interXo2);
      await postNext('Offset t=0', i + 1, {offset: -peakTime, unit: "seconds"});
      let rawSums = [], adjustedSums = [];
      xoIndex.forEach((freq, idx) => {
        const sum1 = (scores1[idx] + scores2[idx]) / 2;
        const sum2 = (scoresAP1[idx] + scoresAP2[idx]) / 2;
        const sum3 = (scores1[idx] + scoresAP2[idx]) / 2;
        const sum4 = (scoresAP1[idx] + scores2[idx]) / 2;
        const adjSum1 = (adjustedScores1[idx] + adjustedScores2[idx]) / 2;
        const adjSum2 = (adjustedScoresAP1[idx] + adjustedScoresAP2[idx]) / 2;
        const adjSum3 = (adjustedScores1[idx] + adjustedScoresAP2[idx]) / 2;
        const adjSum4 = (adjustedScoresAP1[idx] + adjustedScores2[idx]) / 2;
        rawSums.push([sum1, sum2, sum3, sum4]);
        adjustedSums.push([adjSum1, adjSum2, adjSum3, adjSum4]);
        const maxSum = Math.max(sum1, sum2, sum3, sum4);
        const maxSumIndex = [sum1, sum2, sum3, sum4].indexOf(maxSum);
        const allPassConditions = [[false, false], [true, true], [false, true], [true, false]][maxSumIndex];
        if (!frequencyMaxSums[freq]) frequencyMaxSums[freq] = [];
        frequencyMaxSums[freq].push({maxSum, allPassConditions, pair: [commandId[i], commandId[i + 1]]});});
      const printTable = (data) => {
          let rawMinValue = Infinity;
          let rawMaxValue = -Infinity;
          let adjMinValue = Infinity;
          let adjMaxValue = -Infinity;
          data.forEach((row) => {
              [row["Left+Right"], row["(L + R)/AP"], row["L + R w/AP"], row["L w/AP + R"]].forEach(value => {
                  const numericValue = parseFloat(value.replace('%', ''));
                  rawMinValue = Math.min(rawMinValue, numericValue);
                  rawMaxValue = Math.max(rawMaxValue, numericValue);
              });
              [row["TC adjusted  L + R"], row["TC adj. (L + R)/AP"], row["TC adj. L + R w/AP"], row["TC adj. L w/AP + R"]].forEach(value => {
                const numericValue = parseFloat(value.replace('%', ''));
                adjMinValue = Math.min(adjMinValue, numericValue);
                adjMaxValue = Math.max(adjMaxValue, numericValue);
            });
          });
          let tableHTML = '<table style="border-collapse: collapse; width: 68%; font-size: 10px;">';
          tableHTML += '<thead><tr>';
          Object.keys(data[0]).forEach((header) => {
              tableHTML += `<th style="border: 1px solid #22C55E; padding: 1px; text-align: center;">${header}</th>`;
          });
          tableHTML += '</tr></thead><tbody>';
          data.forEach((row) => {
              tableHTML += '<tr>';
              Object.keys(row).forEach((key) => {
                  const value = row[key];
                  const numericValue = parseFloat(value.replace('%', ''));
                  let bgColor = '';
                  if (key !== "Frequency") {
                      if (key.startsWith("Curve adj.")) {
                        bgColor = getColorForValue(numericValue, adjMinValue, adjMaxValue);
                      } else {
                        bgColor = getColorForValue(numericValue, rawMinValue, rawMaxValue);
                      }
                  }
                  tableHTML += `<td style="border: 1px solid #22C55E; padding: 1px; text-align: center; background-color: ${bgColor};">${value}</td>`;
              });
              tableHTML += '</tr>';
          });
          tableHTML += '</tbody></table>';
          logContainer.insertAdjacentHTML('beforeend', tableHTML);};
      const tableData = xoIndex.map((freq, idx) => {
        return {
          Frequency: `${freq}Hz`,
          " Left ": `${scores1[idx].toFixed(2)}%`,
          "L w/AP": `${scoresAP1[idx].toFixed(2)}%`,
          "Right ": `${scores2[idx].toFixed(2)}%`,
          "R w/AP": `${scoresAP2[idx].toFixed(2)}%`,
          "Left+Right": `${rawSums[idx][0].toFixed(2)}%`,
          "(L + R)/AP": `${rawSums[idx][1].toFixed(2)}%`,
          "L + R w/AP": `${rawSums[idx][2].toFixed(2)}%`,
          "L w/AP + R": `${rawSums[idx][3].toFixed(2)}%`,
          "TC adjusted  L + R": `${adjustedSums[idx][0].toFixed(2)}%`,
          "TC adj. (L + R)/AP": `${adjustedSums[idx][1].toFixed(2)}%`,
          "TC adj. L + R w/AP": `${adjustedSums[idx][2].toFixed(2)}%`,
          "TC adj. L w/AP + R": `${adjustedSums[idx][3].toFixed(2)}%`
        };});
      printTable(tableData);
      let bestFreqIdx = -1;
      let bestRawSum = -Infinity;
      let bestAdjustedSum = -Infinity;
      let bestCombination = null;
      adjustedSums.forEach((sums, idx) => {
        sums.forEach((sum, combIdx) => {
          if (sum > bestAdjustedSum) {
            bestAdjustedSum = sum;
            bestFreqIdx = idx;
            bestCombination = combIdx;
          }
        });});
      allPass[i] = bestCombination === 1 || bestCombination === 3;
      allPass[i + 1] = bestCombination === 1 || bestCombination === 2;
      let bestFrequency = xoIndex[bestFreqIdx];
      if (i === 1 && forceLarge) {
        console.warn(`User override: Front speakers will be set to 'Large / Full range' and subwoofer mode will be set to 'LFE + Main`);
        isLarge[1] = isLarge[2] = true;
        bestFrequency = 0;
        allPass[1] = allPass[2] = false;
        await largeFronts();
        bestFrequency = customCrossover[1];
      } else {
        console.log(`Best 'target curve adjusted' crossover frequency for the pair: ${bestFrequency}Hz, pair score: ${bestAdjustedSum.toFixed(2)}%, allpass filters => Left: ${allPass[i]}, Right: ${allPass[i + 1]}`)
      }
      customCrossover[i] = customCrossover[i + 1] = bestFrequency;
      i += 2;
    } else {
      const printSingleSpeakerTable = (data) => {
        let rawMinValue = Infinity;
        let rawMaxValue = -Infinity;
        let adjMinValue = Infinity;
        let adjMaxValue = -Infinity;
        data.forEach((row) => {
          const rawValues = [row["Raw speaker scores "], row["Scores with allpass"]];
          const adjValues = [row["Target curve adjusted scores "], row["TC adjusted scores w/AP filter"]];
          rawValues.forEach(value => {
            const numericValue = parseFloat(value.replace('%', ''));
            rawMinValue = Math.min(rawMinValue, numericValue);
            rawMaxValue = Math.max(rawMaxValue, numericValue);
          });
          adjValues.forEach(value => {
            const numericValue = parseFloat(value.replace('%', ''));
            adjMinValue = Math.min(adjMinValue, numericValue);
            adjMaxValue = Math.max(adjMaxValue, numericValue);
          });
        });
        let tableHTML = '<table style="border-collapse: collapse; width: 55%; font-size: 10px;">';
        tableHTML += '<thead><tr>';
        Object.keys(data[0]).forEach((header) => {
          tableHTML += `<th style="border: 1px solid #22C55E; padding: 1px; text-align: center;">${header}</th>`;
        });
        tableHTML += '</tr></thead><tbody>';
        data.forEach((row) => {
          tableHTML += '<tr>';
          Object.keys(row).forEach((key) => {
            const value = row[key];
            const numericValue = parseFloat(value.replace('%', ''));
            let bgColor = '';
            if (key !== "Frequency") {
              if (key.startsWith("TC adj.")) {
                bgColor = getColorForValue(numericValue, adjMinValue, adjMaxValue);
              } else {
                bgColor = getColorForValue(numericValue, rawMinValue, rawMaxValue);
              }
            }
            tableHTML += `<td style="border: 1px solid #22C55E; padding: 1px; text-align: center; background-color: ${bgColor};">${value}</td>`;
          });
          tableHTML += '</tr>';
        });
        tableHTML += '</tbody></table>';
        logContainer.insertAdjacentHTML('beforeend', tableHTML);};
      const singleSpeakerTableData = xoIndex.map((freq, idx) => {
        const maxSum = Math.max(scores1[idx], scoresAP1[idx]);
        const maxSumIndex = [scores1[idx], scoresAP1[idx]].indexOf(maxSum);
        const allPassConditions = [maxSumIndex === 1];
        if (!frequencyMaxSums[freq]) frequencyMaxSums[freq] = [];
        frequencyMaxSums[freq].push({ maxSum, allPassConditions: [allPassConditions], pair: [commandId[i]] });
        return {
          Frequency: `${freq}Hz`,
          "Raw speaker scores ": `${scores1[idx].toFixed(2)}%`,
          "Scores with allpass": `${scoresAP1[idx].toFixed(2)}%`,
          "Target curve adjusted scores ": `${adjustedScores1[idx].toFixed(2)}%`,
          "TC adjusted scores w/AP filter": `${adjustedScoresAP1[idx].toFixed(2)}%`
        };});
      printSingleSpeakerTable(singleSpeakerTableData);
      const bestRawIndex = scores1.indexOf(Math.max(...scores1));
      const bestRawAPIndex = scoresAP1.indexOf(Math.max(...scoresAP1));
      const bestAdjustedIndex = adjustedScores1.indexOf(Math.max(...adjustedScores1));
      const bestAdjustedAPIndex = adjustedScoresAP1.indexOf(Math.max(...adjustedScoresAP1));
      let bestFrequency =
        adjustedScores1[bestAdjustedIndex] > adjustedScoresAP1[bestAdjustedAPIndex]
          ? xoIndex[bestAdjustedIndex]
          : xoIndex[bestAdjustedAPIndex];
      const bestScore = Math.max(
        adjustedScores1[bestAdjustedIndex],
        adjustedScoresAP1[bestAdjustedAPIndex]);
      allPass[i] = adjustedScores1[bestAdjustedIndex] < adjustedScoresAP1[bestAdjustedAPIndex];
      console.log(`Best 'target curve adjusted' crossover frequency for speaker: ${bestFrequency}Hz, score: ${bestScore.toFixed(2)}%, allpass filter => ${allPass[i]}`);
      customCrossover[i] = bestFrequency;
      i ++;
      singleCount ++;
    }
  }
  if (sameXover) {
    console.infoBold(`Optimal system-wide uniform crossover configuration:`);
    const frequencyTotals = Object.entries(frequencyMaxSums).reduce((totals, [freq, contributions]) => {
        const totalSum = contributions.reduce((sum, entry) => {
            const multiplier = (entry.pair.includes('FL') && favorMains) ? 2 : 1;
            return sum + (entry.maxSum * multiplier);
        }, 0);
        totals[freq] = {totalSum, contributions};
        return totals;
    }, {});
    const bestFrequencyEntry = Object.entries(frequencyTotals).reduce((best, [freq, data]) => {return data.totalSum > best.totalSum ? {freq, ...data} : best;}, {freq: null, totalSum: -Infinity, contributions: []});
    const bestFrequency = bestFrequencyEntry.freq;
    const bestContributions = bestFrequencyEntry.contributions;
    const printAggregateTable = (bestFrequencyEntry) => {
    const {freq: bestFrequency, totalSum, contributions} = bestFrequencyEntry;
    let minValue = Infinity;
    let maxValue = -Infinity;

    contributions.forEach(({ maxSum }) => {
      minValue = Math.min(minValue, maxSum);
      maxValue = Math.max(maxValue, maxSum);
    });
    let tableHTML = '<table style="border-collapse: collapse; width: 40%;">';
    tableHTML += `
      <thead>
        <tr>
          <th style="border: 1px solid #22C55E; padding: 1px; text-align: center; font-style: italic; white-space: normal;">Optimal Uniform Crossover Freq.</th>
          <th style="border: 1px solid #22C55E; padding: 1px; text-align: center; font-style: italic;">Speaker(s)</th>
          <th style="border: 1px solid #22C55E; padding: 1px; text-align: center; font-style: italic;">Performace score</th>
          <th style="border: 1px solid #22C55E; padding: 1px; text-align: center; font-style: italic;">AllPass filter applied</th>
          <th style="border: 1px solid #22C55E; padding: 1px; text-align: center; font-style: italic;">AllPass filter applied</th>
        </tr>
      </thead>
      <tbody>
    `;
    tableHTML += `
      <tr style="font-weight: bold;">
        <td style="border: 1px solid #22C55E; padding: 1px; text-align: center;">${bestFrequency}Hz</td>
        <td style="border: 1px solid #22C55E; padding: 1px; text-align: center;">System overall</td>
        <td style="border: 1px solid #22C55E; padding: 1px; text-align: center;">${(totalSum / ((nSpeakers + (favorMains ? 2 : 0) - singleCount) / 2 + singleCount)).toFixed(2)}%</td>
        <td style="border: 1px solid #22C55E; padding: 1px; text-align: center;">-</td>
        <td style="border: 1px solid #22C55E; padding: 1px; text-align: center;">-</td>
      </tr>
    `;
     contributions.forEach(({ pair, maxSum, allPassConditions = [] }) => {
       const bgColor = getColorForValue(maxSum, minValue, maxValue);
       tableHTML += `
         <tr>
           <td style="border: 1px solid #22C55E; padding: 1px; text-align: center;">${bestFrequency}</td>
           <td style="border: 1px solid #22C55E; padding: 1px; text-align: center;">${pair[1] !== undefined ? `${pair[0]} + ${pair[1]}` : pair[0]}</td>
           <td style="border: 1px solid #22C55E; padding: 1px; text-align: center; background-color: ${bgColor};">${maxSum.toFixed(2)}%</td>
           <td style="border: 1px solid #22C55E; padding: 1px; text-align: center;">${allPassConditions[0] ?? '-'}</td>
           <td style="border: 1px solid #22C55E; padding: 1px; text-align: center;">${pair[1] !== undefined ? (allPassConditions[1] ?? '-') : '-'}</td>
         </tr>
       `;
     });
      tableHTML += '</tbody></table>';
      logContainer.insertAdjacentHTML('beforeend', tableHTML);};
    printAggregateTable(bestFrequencyEntry);
    console.log(`Best uniform system-wide crossover frequency: ${bestFrequency}Hz, score: ${(bestFrequencyEntry.totalSum / ((nSpeakers + (favorMains ? 2 : 0) - singleCount) / 2 + singleCount)).toFixed(2)}%`);
    let i = 1;
    bestContributions.forEach(({pair, maxSum, allPassConditions}) => {
    allPass[i] = allPassConditions[0];
    isLarge[i] = false;
    customCrossover[i] = bestFrequency;
    if (pair[1] !== undefined) {
      allPass[i + 1] = allPassConditions[1];
      isLarge[i + 1] = false;
      customCrossover[i + 1] = bestFrequency;
      i += 2;
    } else {
      i ++;
    }});
  };
}